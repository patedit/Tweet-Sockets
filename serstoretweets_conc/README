
			||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
			||						      		                              ||
			||SERSTORETWEETS_CONC: Programa servidor concurrente de TCP para el almacenamiento de  tweets.||
			||								                              ||
			||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

Información General:  

Esta aplicación permite el almacenamiento de mensajes cortos en directorios de acuerdo a un tópico introducido por el cliente (leer readme de cliposttweet).
Para su ejecución se debe teclear ./serstoretweets junto con una serie de argumentos de entrada que son: <puerto> <backlog> y <tambuffer>.
Se realiza una comprobación de cada uno de los argumentos para garanizar el correcto funcionamiento. En caso de que no se haga de manera adecuada se provocará
la salida inmediata de la aplicación.
La implementación de funciones en este programa sigue la estructura y el orden básico de un servidor TCP de una API de sockets. Se crea un socket,
se deja el servidor a la escucha de peticiones de posibles conexiones, se aceptan las peticiones de las conexiones creando procesos 'hijos' que atiendan a cada cliente. Este servidor es capaz de manejar varios clientes 
simultáneamente y nos los deja en espera de acuerdo con su tamaño de backlog tal y como hacen los servidores iterativos. A continuación se pueden 
leer y/o escribir datos.
Esta aplicación leerá el tópico introducido por el cliente para así decidir dónde almacenarlos. Para ello se recurre a la función storetweet.
La función storetweet comprobará si ya existe un fichero de almacenamiento de tweets con el tópico seleccionado, extraerá de tamaño de búffer en tamaño de búffer
el mensaje que se desea almacenar. Además en caso de que no exista un fichero del tópico seleccionado para almacenar los datos la aplicación es capaz de crearlo.
Simultaneamente a este proceso abrirá un fichero donde se va almacenando el número total de tweets que hay de cada tópico. Al final del proceso de guardado, este
número se verá aumentado en uno ya que se corresponde con el que queremos guardar y que será, por tanto, el último. 

 
Aspectos técnicos:

A continuación se describen ciertos detalles técnicos de importancia de la aplicación:

Es importante destacar que para al implementación de al aplicación se realiza una reserva de memoria. En esta aplicación se realiza la reserva de memoria para
el buffer que se utilizará y para el tópico introducido. Para ello se recurre a la función malloc(), usando como tamaño de buffer el especificado en <tambuffer>. En el caso del tópico usaremos malloc(9) (9=tamaño máximo del tópico+\0).
Hay que resaltar que para el funcionamiento correcto del servidor, en concordancia con el funcionamiento del cliente de envío de tweets, la aplicación leerá
hasta que encuentre un retorno de carro. Una vez leídos los datos enviados por el cliente hasta el \n correspondiente al retorno de carro que nos marca el final 
del tópico introducido, la aplicación deberá resustituir ese \n que nos marca el retorno de carro por un \0. Esto se debe a que para poder trabajar con cadenas
de caracteres el último caracter que se debe almacenar ha de ser un \0.
Esta aplicación realizara búsquedas de ficheros para lo cual se utilizará el comando lstat. En caso de necesitar crear un directorio empleará el comando mkdir.
Es necesario prestar atención a los permisos que se le conceden a los directorios para poder trabajar con ellos. Se debe permitir escritura en ellos.

Para podera tender a varios clientes simultáneamiente es necesario la implementación de un proceso padre que esté a la escucha y que éste cree a su vez los pro-
cesos hijo que sean necesarios para poder atender a la peticiones. Para ello se emplea la función fork(). Es muy importante resaltar que una vez que el proceso
hijo concluye su tarea, el padre deberá acabar con ese proceso  para que no quede como zombie. Para ello el padre ejecutará la función wait() cuando el proceso hijo
termine (ya que manda una señal al kernel), terminando así con ese proceso.
Es de mención detallar que cuando la aplicación se ve interrumpida por la señal que envía el proceso 'hijo', errno toma el valor EINTR.
Si no tenemos en cuenta que esto no es un error en sí mismo, la aplicación terminaría en el accept(), por lo que hay que asegurarse de que no se tenga en cuenta este valor de errno.