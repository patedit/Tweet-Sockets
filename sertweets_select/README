
		||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
		||								                                  ||
		||SERTWEETS_SELECT: Programa servidor concurrente de TCP para el almacenamiento y envío de tweets.||
		||								                                  ||
		||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

Información General:  

Esta aplicación permite el almacenamiento de mensajes cortos en directorios de acuerdo a un tópico introducido por el cliente (leer readme de cliposttweet)
así como el envío de mensajes cortos alamcenados en directorios de acuerdo a un tópico introducido por el cliente (leer readme de cligettweet).
Para su ejecución se debe teclear ./sertweets_select junto con una serie de argumentos de entrada que son: <puerto> <backlog> y <tambuffer>.
Se realiza una comprobación de cada uno de los argumentos para garanizar el correcto funcionamiento. En caso de que no se haga de manera adecuada se provocará
la salida inmediata de la aplicación.
La implementación de funciones en este programa sigue la estructura y el orden básico de un servidor TCP de una API de sockets. Se crea un socket,
se deja el servidor a la escucha de peticiones de posibles conexiones, se acepta las peticiones de las conexiones, se aceptan las peticiones de las conexiones creando procesos 'hijos' que atiendan a cada cliente. Este servidor es capaz de manejar varios clientes 
simultáneamente y nos los deja en espera de acuerdo con su tamaño de backlog tal y como hacen los servidores iterativos. A continuación se pueden 
leer y/o escribir datos.
Esta aplicación permanecerá a la escucha de dos puertos uno destinado para la recepción y el almacenamientos de tweets y otro para el envío.
Por el primer puerto: se leerá el tópico introducido por el cliente para así decidir dónde almacenarlos. Para ello se recurre a la función storetweet.
La función storetweet comprobará si ya existe un fichero de almacenamiento de tweets con el tópico seleccionado, extraerá de tamaño de búffer en tamaño de búffer
el mensaje que se desea almacenar. Además en caso de que no exista un fichero del tópico seleccionado para almacenar los datos la aplicación es capaz de crearlo.
Simultaneamente a este proceso abrirá un fichero donde se va almacenando el número total de tweets que hay de cada tópico. Al final del proceso de guardado, este
número se verá aumentado en uno ya que se corresponde con el que queremos guardar y que será, por tanto, el último. 

Por el segundo puerto: se leerá el tópico introducido por el cliente para así poder seleccionar el mensaje que el cliente desea leer. Para ello se recurre a la 
función sendtweet.
La función sendtweet abrirá el fichero donde se almacenan el número total de tweets del tópico seleccionado que tiene el programa e informará al cliente de 
cuantos hay. Después recibirá el número que el usuario desea leer y si este número no contiene errores se le transimitirá al cliente de tamaño de búffer en 
tamaño de búffer bytes el mensaje almacenado. 

 
Aspectos técnicos:

A continuación se describen ciertos detalles técnicos de importancia de la aplicación:

Es fundamental para el correcto funcionamiento de esta aplicación la creación de dos sockets uno para un puerto de valor <puerto> y otro para <puerto+1>
Es necesario el empleo de las funciones FD_SET para añadir el descriptor de fichero fd al conjunto set. Para garantizar que se añade de manera correcta el 
descriptor de fichero incluso en casos en los que haya habido algún error es necesario la utilización de la función FD_ZERO que vacía el conjunto set de descriptores.
Es importante destacar que para al implementación de la aplicación, se realiza una reserva de memoria. En esta aplicación se realiza la reserva de memoria para
el buffer que se utilizará y para el tópico introducido. Para ello se recurre a la función malloc().
Hay que resaltar que para el funcionamiento correcto del servidor, en concordancia con el funcionamiento del cliente de envío de tweets, la aplicación leerá
hasta que encuentre un retorno de carro. Una vez leídos los datos enviados por el cliente hasta el \n correspondiente al retorno de carro que nos marca el final 
del tópico introducido, la aplicación deberá resustituir ese \n que nos marca el retorno de carro por un \0. Esto se debe a que para poder trabajar con cadenas
de caracteres el último caracter que se debe almacenar ha de ser un \0.
Esta aplicación realizara búsquedas de ficheros para lo cual se utilizará el comando lstat. En caso de necesitar crear un directorio empleará el comando mkdir.
Es necesario prestar atención a los permisos que se le conceden a los directorios para poder trabajar con ellos. Se debe permitir escritura en ellos.
Para podera tender a varios clientes simultáneamiente es necesario la implementación de un proceso padre que esté a la escucha y que éste cree a su vez los pro-
cesos hijo que sean necesarios para poder atender a la peticiones. Para ello se emplea la función fork(). Es muy importante resaltar que una vez que el proceso
hijo concluye su tarea, el padre deberá acabar con ese proceso  para que no quede como zombies. Para ello el padre ejecutará la función wait() cuando el proceso hijo
termine (ya que manda una señal al kernel), terminando así con ese proceso.
Es de mención detallar que cuando la aplicación se ve interrumpida por la señal que envía el proceso 'hijo', errno toma el valor EINTR.
Si no tenemos en cuenta que esto no es un error en sí mismo, la aplicación terminaría en el accept() o select(), por lo que hay que asegurarse de que no se tenga en cuenta este valor de errno.